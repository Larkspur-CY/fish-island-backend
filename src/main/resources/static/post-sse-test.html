<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>POST + SSE 流式测试（现代AI标准）</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            padding: 20px; 
            background: #f0f2f5; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 20px; 
            border-radius: 10px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        .methods { 
            display: flex; 
            gap: 20px; 
            margin-top: 20px; 
        }
        .method-section { 
            flex: 1; 
            border: 2px solid #e1e8ed; 
            padding: 20px; 
            border-radius: 10px; 
            background: #fafbfc;
        }
        .get-method { border-left: 4px solid #1da1f2; }
        .post-method { border-left: 4px solid #e1306c; }
        
        h3 {
            margin-top: 0;
            color: #14171a;
        }
        .get-method h3::before { content: "🔹 "; color: #1da1f2; }
        .post-method h3::before { content: "🔸 "; color: #e1306c; }
        
        button { 
            padding: 12px 24px; 
            margin: 5px; 
            color: white; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer; 
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .get-method button { 
            background: linear-gradient(135deg, #1da1f2, #0d8bd9); 
        }
        .post-method button { 
            background: linear-gradient(135deg, #e1306c, #c13584); 
        }
        button:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        button:disabled { 
            background: #aab8c2; 
            transform: none;
            box-shadow: none;
            cursor: not-allowed;
        }
        
        .input-group {
            margin: 15px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #14171a;
        }
        input, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #e1e8ed;
            border-radius: 6px;
            font-size: 14px;
        }
        textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        .result { 
            border: 1px solid #e1e8ed; 
            padding: 15px; 
            margin: 15px 0; 
            min-height: 120px; 
            background: white;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
        }
        .debug { 
            background: #f7f9fa; 
            padding: 15px; 
            margin: 15px 0; 
            font-family: 'Courier New', monospace; 
            max-height: 250px; 
            overflow-y: auto;
            border-radius: 6px;
            border: 1px solid #e1e8ed;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .status {
            padding: 6px 12px;
            border-radius: 20px;
            display: inline-block;
            margin: 8px 0;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .status.connecting { background: #fff3cd; color: #856404; }
        .status.connected { background: #d4edda; color: #155724; }
        .status.completed { background: #d1ecf1; color: #0c5460; }
        .status.error { background: #f8d7da; color: #721c24; }
        
        .comparison-info {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 30px;
        }
        .comparison-info h4 {
            margin-top: 0;
        }
        .comparison-info ul {
            margin: 0;
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 POST + SSE 流式测试（模拟数据）</h1>
            <p>测试现代 AI 服务标准：POST 请求 + Server-Sent Events 响应（使用模拟数据）</p>
        </div>
        
        <div class="methods">
            <!-- GET 方式测试 -->
            <div class="method-section get-method">
                <h3>GET 请求方式（传统）</h3>
                <div class="status" id="getStatus">待测试</div>
                
                <div class="input-group">
                    <label>测试消息：</label>
                    <input type="text" id="getMessage" value="GET方式测试消息" placeholder="输入测试消息">
                </div>
                
                <button onclick="testGetMethod()">开始 GET 测试</button>
                <button onclick="stopGet()">停止</button>
                
                <div><strong>实时结果：</strong></div>
                <div id="getResult" class="result">等待测试...</div>
                
                <div><strong>调试日志：</strong></div>
                <div id="getDebug" class="debug"></div>
            </div>
            
            <!-- POST 方式测试 -->
            <div class="method-section post-method">
                <h3>POST 请求方式（现代AI标准）</h3>
                <div class="status" id="postStatus">待测试</div>
                
                <div class="input-group">
                    <label>请求消息：</label>
                    <textarea id="postMessage" placeholder="输入复杂的聊天消息或JSON数据">POST方式可以发送复杂的对话历史、配置参数等（模拟数据测试）</textarea>
                </div>
                
                <button onclick="testPostMethod()">开始 POST 测试</button>
                <button onclick="testPostTyping()">打字效果测试</button>
                <button onclick="stopPost()">停止</button>
                
                <div><strong>实时结果：</strong></div>
                <div id="postResult" class="result">等待测试...</div>
                
                <div><strong>调试日志：</strong></div>
                <div id="postDebug" class="debug"></div>
            </div>
        </div>
        
        <div class="comparison-info">
            <h4>📋 GET vs POST + SSE 对比</h4>
            <div style="display: flex; gap: 30px;">
                <div style="flex: 1;">
                    <strong>GET + SSE（传统方式）：</strong>
                    <ul>
                        <li>参数通过 URL 传递</li>
                        <li>有长度限制（约2KB）</li>
                        <li>不适合复杂对话</li>
                        <li>缓存友好但不适合流式</li>
                    </ul>
                </div>
                <div style="flex: 1;">
                    <strong>POST + SSE（现代标准）：</strong>
                    <ul>
                        <li>复杂数据通过请求体发送</li>
                        <li>无长度限制</li>
                        <li>支持聊天历史、配置等</li>
                        <li>Kimi、DeepSeek、OpenAI 标准</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        let getEventSource = null;
        let postAbortController = null;  // 改为 AbortController 控制 POST 请求
        let getCompleted = false;
        let postCompleted = false;
        
        function updateStatus(type, status, text) {
            const statusDiv = document.getElementById(type + 'Status');
            statusDiv.className = 'status ' + status;
            statusDiv.textContent = text;
        }
        
        function addDebug(type, message) {
            const debugDiv = document.getElementById(type + 'Debug');
            const time = new Date().toLocaleTimeString();
            debugDiv.innerHTML += `<div style="margin: 2px 0;">[${time}] ${message}</div>`;
            debugDiv.scrollTop = debugDiv.scrollHeight;
        }
        
        function updateResult(type, content) {
            document.getElementById(type + 'Result').innerHTML = content;
        }
        
        // GET 方式测试（传统SSE）
        function testGetMethod() {
            if (getEventSource) {
                getEventSource.close();
            }
            
            getCompleted = false;
            const message = document.getElementById('getMessage').value;
            const url = `/api/chat/stream/mock?message=${encodeURIComponent(message)}`;
            
            startSSEConnection(url, 'get', 'getEventSource');
        }
        
        // POST 方式测试（真正的POST + SSE）
        async function testPostMethod() {
            if (postAbortController) {
                postAbortController.abort();
            }
            
            postAbortController = new AbortController();
            postCompleted = false;
            const message = document.getElementById('postMessage').value;
            
            let accumulatedText = '';
            let dataCount = 0;
            let startTime = Date.now();
            let buffer = ''; // 缓冲区处理不完整的数据
            
            // 更新状态和清空显示
            updateStatus('post', 'connecting', '连接中...');
            updateResult('post', '🔄 正在发送POST请求...');
            document.getElementById('post' + 'Debug').innerHTML = '';
            addDebug('post', '🚀 发送POST请求到: /api/chat/stream/mock-post');
            addDebug('post', '📤 POST数据: ' + JSON.stringify({message: message}));
            
            try {
                // 🔥 真正的 POST + SSE 实现（调用模拟数据接口）
                const response = await fetch('/api/chat/stream/mock-post', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        message: message
                    }),
                    signal: postAbortController.signal  // 支持取消请求
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                updateStatus('post', 'connected', '已连接');
                addDebug('post', '✅ POST请求成功，开始接收流式数据...');
                
                // 处理流式响应
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) {
                        addDebug('post', '🏁 流式数据接收完成！');
                        updateStatus('post', 'completed', '传输完成');
                        postCompleted = true;
                        break;
                    }
                    
                    // 解码并累积到缓冲区
                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;
                    
                    // 处理缓冲区中的完整行
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || ''; // 保留最后一行（可能不完整）
                    
                    for (const line of lines) {
                        if (line.startsWith('data:')) {
                            dataCount++;
                            const elapsed = Date.now() - startTime;
                            const data = line.slice(5); // 去掉 "data:" 前缀
                            
                            addDebug('post', `📨 第${dataCount}次接收 (${elapsed}ms): "${data}"`);
                            
                            if (data === '[DONE]') {
                                postCompleted = true;
                                updateStatus('post', 'completed', '传输完成');
                                addDebug('post', `🏁 数据接收完成！总计 ${dataCount} 次，耗时 ${elapsed}ms`);
                                updateResult('post', '<div style="color: #28a745; font-weight: bold;">✅ 最终结果：</div><div style="background: #f8fff9; padding: 10px; border-radius: 4px; margin-top: 8px;">' + accumulatedText + '</div>');
                                return;
                            }
                            
                            // 🔥 关键拼接逻辑 - 参考GET请求的简单拼接
                            const oldText = accumulatedText;
                            accumulatedText += data; // 直接拼接，与GET请求一致
                            
                            addDebug('post', `🔗 数据拼接: "${oldText}" + "${data}"`);
                            
                            // 实时更新显示
                            updateResult('post', '<div style="color: #495057; font-weight: bold;">📝 实时拼接内容：</div><div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-top: 8px;">' + accumulatedText + '</div>');
                        }
                    }
                }
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    addDebug('post', '🛑 请求已被取消');
                    updateStatus('post', 'error', '手动停止');
                } else {
                    updateStatus('post', 'error', '请求失败');
                    addDebug('post', '❌ POST请求失败: ' + error.message);
                    updateResult('post', '<div style="color: #dc3545; font-weight: bold;">❌ 请求失败: ' + error.message + '</div>');
                }
            }
        }
        
        function startSSEConnection(url, type, eventSourceVar) {
            let accumulatedText = '';
            let dataCount = 0;
            let startTime = Date.now();
            
            // 重置完成状态
            if (type === 'get') {
                getCompleted = false;
            } else if (type === 'post') {
                postCompleted = false;
            }
            
            // 更新状态和清空显示
            updateStatus(type, 'connecting', '连接中...');
            updateResult(type, '🔄 正在建立SSE连接...');
            document.getElementById(type + 'Debug').innerHTML = '';
            addDebug(type, '🚀 开始连接: ' + url);
            
            window[eventSourceVar] = new EventSource(url);
            
            window[eventSourceVar].onopen = function() {
                updateStatus(type, 'connected', '已连接');
                addDebug(type, '✅ SSE连接成功，开始接收流式数据...');
            };
            
            window[eventSourceVar].onmessage = function(event) {
                dataCount++;
                const elapsed = Date.now() - startTime;
                addDebug(type, `📨 第${dataCount}次接收 (${elapsed}ms): "${event.data}"`);
                
                if (event.data === '[DONE]') {
                    // 标记为完成状态
                    if (type === 'get') {
                        getCompleted = true;
                    } else if (type === 'post') {
                        postCompleted = true;
                    }
                    
                    updateStatus(type, 'completed', '传输完成');
                    addDebug(type, `🏁 流式数据接收完成！总计 ${dataCount} 次，耗时 ${elapsed}ms`);
                    window[eventSourceVar].close();
                    updateResult(type, '<div style="color: #28a745; font-weight: bold;">✅ 最终结果：</div><div style="background: #f8fff9; padding: 10px; border-radius: 4px; margin-top: 8px;">' + accumulatedText + '</div>');
                    return;
                }
                
                // 🔥 关键拼接逻辑
                const oldText = accumulatedText;
                accumulatedText += event.data;
                
                addDebug(type, `🔗 数据拼接: "${oldText}" + "${event.data}"`);
                
                // 实时更新显示
                updateResult(type, '<div style="color: #495057; font-weight: bold;">📝 实时拼接内容：</div><div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-top: 8px;">' + accumulatedText + '</div>');
            };
            
            window[eventSourceVar].onerror = function(error) {
                // 检查连接是否已经完成，避免误报错误
                const isCompleted = (type === 'get' && getCompleted) || 
                                   (type === 'post' && postCompleted);
                                   
                if (isCompleted || window[eventSourceVar].readyState === EventSource.CLOSED) {
                    addDebug(type, '✅ 连接正常关闭');
                    return;
                }
                
                updateStatus(type, 'error', '连接错误');
                addDebug(type, '❌ SSE连接错误: ' + JSON.stringify(error));
                updateResult(type, '<div style="color: #dc3545; font-weight: bold;">❌ 连接错误</div>');
            };
        }
        
        function stopGet() {
            if (getEventSource && getEventSource.readyState !== EventSource.CLOSED) {
                getEventSource.close();
                updateStatus('get', 'error', '手动停止');
                addDebug('get', '🛑 手动停止GET连接');
            }
        }
        
        // POST 打字效果测试
        async function testPostTyping() {
            if (postAbortController) {
                postAbortController.abort();
            }
            
            postAbortController = new AbortController();
            postCompleted = false;
            const message = document.getElementById('postMessage').value;
            
            let accumulatedText = '';
            let dataCount = 0;
            let startTime = Date.now();
            let buffer = ''; // 缓冲区处理不完整的数据
            
            // 更新状态和清空显示
            updateStatus('post', 'connecting', '连接中...');
            updateResult('post', '🔄 正在发送POST打字效果请求...');
            document.getElementById('post' + 'Debug').innerHTML = '';
            addDebug('post', '🚀 发送POST打字效果请求到: /api/chat/stream/typing-post');
            addDebug('post', '📤 POST数据: ' + JSON.stringify({text: message}));
            
            try {
                // 🔥 真正的 POST + SSE 打字效果实现（调用模拟数据接口）
                const response = await fetch('/api/chat/stream/typing-post', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream',
                        'Cache-Control': 'no-cache'
                    },
                    body: JSON.stringify({
                        text: message
                    }),
                    signal: postAbortController.signal  // 支持取消请求
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                updateStatus('post', 'connected', '已连接');
                addDebug('post', '✅ POST打字效果请求成功，开始接收流式数据...');
                
                // 处理流式响应
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) {
                        addDebug('post', '🏁 打字效果流式数据接收完成！');
                        updateStatus('post', 'completed', '传输完成');
                        postCompleted = true;
                        break;
                    }
                    
                    // 解码并累积到缓冲区
                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;
                    
                    // 处理缓冲区中的完整行
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || ''; // 保留最后一行（可能不完整）
                    
                    for (const line of lines) {
                        if (line.startsWith('data:')) {
                            dataCount++;
                            const elapsed = Date.now() - startTime;
                            const data = line.slice(5); // 去掉 "data:" 前缀
                            
                            addDebug('post', `📨 第${dataCount}次接收 (${elapsed}ms): "${data}"`);
                            
                            if (data === '[DONE]') {
                                postCompleted = true;
                                updateStatus('post', 'completed', '传输完成');
                                addDebug('post', `🏁 打字效果数据接收完成！总计 ${dataCount} 次，耗时 ${elapsed}ms`);
                                updateResult('post', '<div style="color: #28a745; font-weight: bold;">✅ 打字效果最终结果：</div><div style="background: #f8fff9; padding: 10px; border-radius: 4px; margin-top: 8px;">' + accumulatedText + '</div>');
                                return;
                            }
                            
                            // 🔥 关键拼接逻辑 - 打字效果直接拼接
                            const oldText = accumulatedText;
                            accumulatedText += data; // 打字效果直接拼接
                            
                            addDebug('post', `🔗 数据拼接: "${oldText}" + "${data}"`);
                            
                            // 实时更新显示
                            updateResult('post', '<div style="color: #495057; font-weight: bold;">📝 打字效果实时内容：</div><div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-top: 8px;">' + accumulatedText + '</div>');
                        }
                    }
                }
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    addDebug('post', '🛑 打字效果请求已被取消');
                    updateStatus('post', 'error', '手动停止');
                } else {
                    updateStatus('post', 'error', '请求失败');
                    addDebug('post', '❌ POST打字效果请求失败: ' + error.message);
                    updateResult('post', '<div style="color: #dc3545; font-weight: bold;">❌ 打字效果请求失败: ' + error.message + '</div>');
                }
            }
        }
        
        function stopPost() {
            if (postAbortController) {
                postAbortController.abort();
                updateStatus('post', 'error', '手动停止');
                addDebug('post', '🛑 手动取消POST请求');
                postAbortController = null;
            }
        }
        
        // 页面加载时显示说明
        window.onload = function() {
            addDebug('get', '💡 GET方式：通过URL参数传递数据，适合简单场景（模拟数据）');
            addDebug('post', '💡 POST方式：通过请求体传递复杂数据，现代AI服务标准（模拟数据）');
        };
    </script>
</body>
</html>